# 纹理基础



## 纹理的概念

宏观表现为一张图片

<img src="https://docimg10.docs.qq.com/image/JyywxlqAar0lwSimiz376A?w=500&h=500" alt="img" style="zoom:50%;" />

实际上是一种可供着色器读写的结构化存储方式，包含宽高以及对应RGBA数值的信息，也可以用来存储高度，纹理通道，法线等



## 纹理的作用

一种模拟物体表面的技术

比起直接建立一个完整的模型，我们不如直接在模型表面贴上一张“贴图”，这样就能节约很多成本

通过纹理，能够**减少建模工作量，节省存储空间，增加读取速度** 

其缺点是**牺牲了几何细节** 



## 纹理管线

类似于渲染管线，我们把纹理如何起作用的流程叫做纹理管线

<img src="https://docimg2.docs.qq.com/image/JMipWQukJz0ZSRl-kamThA?w=527&h=130" alt="img" style="zoom:150%;" />

<center>模型空间位置=>投影函数=>纹理映射=>纹理坐标=>通讯函数=>新纹理坐标=>纹理采样(避免依赖纹理读取)=>纹理值</center>



### 投影函数

* 与投影变换是完全不同的概念

将物体的顶点信息从模型空间投影到纹理坐标空间中，转化成纹理坐标，也就是uv坐标，通常这一步在俗称“展uv”的阶段中使用，随后讲投影的结果存储在顶点数据中

一般情况下我们是不用管投影函数的，但一些特殊的渲染情况使用特定的投影函数实现的，比如说环境渲染



### 纹理采样

纹理坐标（uv坐标）通过通讯函数进行平移，旋转，缩放，或者控制图像的应用方式之后，得到新的uv坐标

在这个新的uv坐标上，我们求可以通过纹理采样获取纹理值了



* 着色器中的纹理通常以Sample Variable也就是采样器变量的形式存在，这就是在代码里经常看到的Sample
* Sample 是uniform类型的变量，在处理不同的片元时，该量保持不变，一个Sample跟一个纹理对应



#### 依赖纹理读取

当使用Texture 2D或者类似的方式访问纹理的时候，只要像素着色器不是直接用顶点着色器传值，没有经过数值修改，就会需要依赖纹理读取

依赖纹理读取会对性能产生影响，所以我们尽量把这些相关的计算放在带点着色器完成

* 大部分实时渲染用到的都是图像纹理，用Lookup函数来索引值，小部分程序纹理涉及到的不是内存查找，而是函数计算，它们获取到的结果都是RGBA四个值，或者别的数据





<img src="https://docimg7.docs.qq.com/image/wGtQaKVZGJws9NTX5g8J-g?w=538&h=250" alt="img" style="zoom:200%;" />

<center>流程图</center>

模型坐标经过投影函数变换为uv坐标（0.32,0.29），假如这种纹理是256x256，那么让uv坐标乘以256得到(81,74)，随后通过采样的方式（插值，Bilinear，Bicubic，Mipmap，各向异性过滤）得到对应的纹理值



#### Wrap Mode

决定模型坐标被映射到了uv值[0.1]以外时的操作

OpenGL：“包装模式”（Wrapping Model）

Directx：“纹理寻址模式”（Texture Addressing Mode）

<img src="https://docimg2.docs.qq.com/image/3NxPNycJnowolhI181Yt7A?w=543&h=157" alt="img" style="zoom:200%;" />

<center> Repeat               Mirror               Clamp               Border</center>

* 中间图像为原纹理图像，对应uv值[0,1]，周围的图像就是对纹理进行拓展的操作，拓展后超出[0,1]的部分也能采样获取纹理值了。此处有四种拓展方式



#### Filter Mode

<img src="https://docimg4.docs.qq.com/image/KbM5yjrohQ0ki6T7LGErzA?w=482&h=183" alt="img" style="zoom:150%;" />

<center> 最近邻                     双线性插值                  立方卷积</center>

此处详见GAME101课程，当纹理过小或过大都要相应的采样方式解决问题